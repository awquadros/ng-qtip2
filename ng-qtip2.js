// Generated by CoffeeScript 1.10.0
(function() {
  var NgQtip2;

  NgQtip2 = function($timeout, $compile, $http, $templateCache) {
    return {
      restrict: 'A',
      scope: {
        qtipVisible: '=?',
        qtipDisable: '=?',
        qtipFixed: '&?',
        qtipDelay: '&?',
        qtipAdjustX: '@',
        qtipAdjustY: '@',
        qtipModalStyle: '&?',
        qtipTipStyle: '&?',
        qtipShowEffect: '&?',
        qtipPersistent: '&?',
        qtip: '@',
        qtipTitle: '@',
        qtipTarget: '@',
        qtipContent: '@',
        qtipSelector: '@',
        qtipTemplate: '@',
        qtipEvent: '@',
        qtipEventOut: '@',
        qtipHide: '&?',
        qtipShow: '&?',
        qtipClass: '@',
        qtipMy: '@',
        qtipAt: '@',
        qtipOptions: '&?',
        object: '=qtipTemplateObject'
      },
      link: function(scope, el, attrs) {
        var content, generateQtip, ref, str2bool;
        str2bool = function(str) {
          var ref;
          return (ref = String(str).toLowerCase()) !== 'false' && ref !== '0' && ref !== 'null' && ref !== '';
        };
        scope.closeQtip = function(e, id, arg) {
          var qtEl, ref, rendered;
          if (id == null) {
            id = el.data('hasqtip');
          }
          rendered = (ref = (arg != null ? arg : {}).rendered) != null ? ref : false;
          if (e != null) {
            if (typeof e.preventDefault === "function") {
              e.preventDefault();
            }
          }
          qtEl = $("#qtip-" + id);
          qtEl.qtip('hide');
          if (!scope.qtipPersistent()) {
            qtEl.qtip().rendered = false;
          }
        };
        generateQtip = function(content) {
          var options, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
          options = {
            position: {
              my: (ref = scope.qtipMy) != null ? ref : 'bottom center',
              at: (ref1 = scope.qtipAt) != null ? ref1 : 'top center',
              target: scope.qtipTarget != null ? $(scope.qtipTarget) : el,
              adjust: {
                x: scope.qtipAdjustX != null ? parseInt(scope.qtipAdjustX) : 0,
                y: scope.qtipAdjustY != null ? parseInt(scope.qtipAdjustY) : 0
              },
              effect: (ref2 = typeof scope.qtipShowEffect === "function" ? scope.qtipShowEffect() : void 0) != null ? ref2 : true
            },
            show: {
              event: (ref3 = scope.qtipEvent) != null ? ref3 : 'mouseover'
            },
            hide: {
              fixed: (typeof scope.qtipFixed === "function" ? scope.qtipFixed() : void 0) ? str2bool(scope.qtipFixed) : true,
              delay: (ref4 = scope.qtipDelay) != null ? ref4 : 100,
              event: (ref5 = scope.qtipEventOut) != null ? ref5 : 'mouseout'
            },
            style: {
              classes: (ref6 = scope.qtipClass) != null ? ref6 : 'qtip',
              modal: (ref7 = typeof scope.qtipModalStyle === "function" ? scope.qtipModalStyle() : void 0) != null ? ref7 : {},
              tip: (ref8 = typeof scope.qtipTipStyle === "function" ? scope.qtipTipStyle() : void 0) != null ? ref8 : {}
            }
          };
          if (scope.qtipHide != null) {
            options.hide = typeof scope.qtipHide === "function" ? scope.qtipHide() : void 0;
          }
          if (scope.qtipShow != null) {
            options.show = typeof scope.qtipShow === "function" ? scope.qtipShow() : void 0;
          }
          if (typeof (typeof scope.qtipOptions === "function" ? scope.qtipOptions() : void 0) === 'object') {
            options = angular.extend({}, options, scope.qtipOptions());
          }
          options.content = content != null ? content : {
            text: (ref9 = scope.qtipContent) != null ? ref9 : scope.qtip
          };
          ($(el)).qtip(options);
          if (attrs.qtipVisible != null) {
            scope.$watch('qtipVisible', function(newVal) {
              return ($(el)).qtip('toggle', newVal);
            });
          }
          if (attrs.qtipDisable != null) {
            scope.$watch('qtipDisable', function(newVal) {
              return ($(el)).qtip('disable', newVal);
            });
          }
          if (scope.qtipTitle != null) {
            scope.$watch('qtipTitle', function(newVal) {
              return ($(el)).qtip('option', 'content.title', newVal);
            });
          }
          return scope.$watch('qtip', function(newVal, oldVal) {
            if (newVal !== oldVal) {
              return ($(el)).qtip('option', 'content.text', newVal);
            }
          });
        };
        if (attrs.qtipSelector) {
          $timeout(function() {
            return generateQtip(($(scope.qtipSelector)).html());
          });
        } else if (scope.qtipTemplate != null) {
          $http.get(scope.qtipTemplate, {
            cache: $templateCache
          }).then(function(html) {
            return generateQtip({
              text: function() {
                return $timeout(function() {
                  return scope.$apply(function() {
                    var text;
                    text = $compile(html.data)(scope);
                    return text;
                  });
                });
              }
            });
          });
        } else if (scope.qtipTitle != null) {
          generateQtip({
            title: scope.qtipTitle,
            text: scope.qtip
          });
        } else {
          content = (ref = scope.qtip) != null ? ref : scope.qtipContent;
          generateQtip({
            text: function() {
              return $timeout(function() {
                return scope.$apply(function() {
                  return $compile("<div>" + content + "</div>")(scope);
                });
              });
            }
          });
        }
      }
    };
  };

  NgQtip2.$inject = ['$timeout', '$compile', '$http', '$templateCache'];

  angular.module('ngQtip2', []).directive('qtip', NgQtip2);

}).call(this);
